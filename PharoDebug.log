THERE_BE_DRAGONS_HERE
Process>>debugWithTitle:
8 January 2025 2:35:07.463349 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

Process>>debugWithTitle:
	Receiver: a Process in nil
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	nil
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	nil
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 10 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	339526
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 10 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	339526
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 10 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :bars | self uniqueInstance close: bars last ]
	Arguments and temporary variables: 
		anArg: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840)[..]
	Receiver's instance variables: 
		outerContext: 	SystemProgressMorph class>>endJob:
		compiledBlock: 	a CompiledBlock: [ :bars | self uniqueInstance close: bars l[..]
		numArgs: 	1
		receiver: 	SystemProgressMorph


Array(Collection)>>ifNotEmpty:
	Receiver: an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) a JobProgressMorp[..]
	Arguments and temporary variables: 
		aBlock: 	[ :bars | self uniqueInstance close: bars last ]
	Receiver's instance variables: 
an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) a JobProgressMorp[..]

SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0


MessageSend>>value:
	Receiver: MessageSend(#endJob: -> SystemProgressMorph)
	Arguments and temporary variables: 
		anObject: 	a JobEnd
	Receiver's instance variables: 
		receiver: 	SystemProgressMorph
		selector: 	#endJob:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#endJob: -> SystemProgressMorph)
	Arguments and temporary variables: 
		arg: 	a JobEnd
	Receiver's instance variables: 
		receiver: 	SystemProgressMorph
		selector: 	#endJob:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#endJob: -> SystemProgressMorph)
	Arguments and temporary variables: 
		arg1: 	a JobEnd
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	SystemProgressMorph
		selector: 	#endJob:
		arguments: 	#()


[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a JobEnd
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	JobEnd
		subscriber: 	SystemProgressMorph
		action: 	MessageSend(#endJob: -> SystemProgressMorph)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [action cull: anAnnouncement cull: announcer]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx[..]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		compiledBlock: 	a CompiledBlock: [action cull: anAnnouncement cull: announcer]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription


FullBlockClosure(BlockClosure)>>on:fork:
	Receiver: [action cull: anAnnouncement cull: announcer]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[:ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		compiledBlock: 	a CompiledBlock: [action cull: anAnnouncement cull: announcer]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a JobEnd
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	JobEnd
		subscriber: 	SystemProgressMorph
		action: 	MessageSend(#endJob: -> SystemProgressMorph)


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a JobEnd
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription)
		startIndex: 	1
		index: 	2
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSu[..]
		monitor: 	a Semaphore()



--- The full stack ---
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
8 January 2025 2:35:07.514659 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

Process>>debugWithTitle:
	Receiver: a Process in nil
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	nil
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	nil
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(328@59) corner: (344@75)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(328@59) corner: (344@75)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(717648128)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(328@59) mouseUp 339546 nil]
		targetOffset: 	(306.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 13 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	339526
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 13 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	339526
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 13 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :bars | self uniqueInstance close: bars last ]
	Arguments and temporary variables: 
		anArg: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840)[..]
	Receiver's instance variables: 
		outerContext: 	SystemProgressMorph class>>endJob:
		compiledBlock: 	a CompiledBlock: [ :bars | self uniqueInstance close: bars l[..]
		numArgs: 	1
		receiver: 	SystemProgressMorph


Array(Collection)>>ifNotEmpty:
	Receiver: an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) a JobProgressMorp[..]
	Arguments and temporary variables: 
		aBlock: 	[ :bars | self uniqueInstance close: bars last ]
	Receiver's instance variables: 
an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) a JobProgressMorp[..]

SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0


MessageSend>>value:
	Receiver: MessageSend(#endJob: -> SystemProgressMorph)
	Arguments and temporary variables: 
		anObject: 	a JobEnd
	Receiver's instance variables: 
		receiver: 	SystemProgressMorph
		selector: 	#endJob:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#endJob: -> SystemProgressMorph)
	Arguments and temporary variables: 
		arg: 	a JobEnd
	Receiver's instance variables: 
		receiver: 	SystemProgressMorph
		selector: 	#endJob:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#endJob: -> SystemProgressMorph)
	Arguments and temporary variables: 
		arg1: 	a JobEnd
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	SystemProgressMorph
		selector: 	#endJob:
		arguments: 	#()


[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a JobEnd
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	JobEnd
		subscriber: 	SystemProgressMorph
		action: 	MessageSend(#endJob: -> SystemProgressMorph)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [action cull: anAnnouncement cull: announcer]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx[..]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		compiledBlock: 	a CompiledBlock: [action cull: anAnnouncement cull: announcer]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription


FullBlockClosure(BlockClosure)>>on:fork:
	Receiver: [action cull: anAnnouncement cull: announcer]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[:ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		compiledBlock: 	a CompiledBlock: [action cull: anAnnouncement cull: announcer]
		numArgs: 	0
		receiver: 	an AnnouncementSubscription


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a JobEnd
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	JobEnd
		subscriber: 	SystemProgressMorph
		action: 	MessageSend(#endJob: -> SystemProgressMorph)


[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a JobEnd
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription)
		startIndex: 	1
		index: 	2
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSu[..]
		monitor: 	a Semaphore()



--- The full stack ---
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
OupsDebuggerSystem>>suspendDebuggedProcess:
8 January 2025 2:35:11.037679 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	343204
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	343204
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
8 January 2025 2:35:11.074627 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@54) corner: (353@70)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@54) corner: (353@70)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(791250432)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@54) mouseUp 343212 nil]
		targetOffset: 	(315.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	343204
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	343204
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
OupsDebuggerSystem>>suspendDebuggedProcess:
8 January 2025 2:35:11.861703 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	344036
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	344036
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
8 January 2025 2:35:11.902623 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(342@90) corner: (358@106)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(342@90) corner: (358@106)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(13679872)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(342@90) mouseUp 344048 nil]
		targetOffset: 	(320.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	344036
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	344036
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
OupsDebuggerSystem>>suspendDebuggedProcess:
8 January 2025 2:35:12.656917 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	344839
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	344839
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
8 January 2025 2:35:12.695413 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(690947072)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 344857 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	344839
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	344839
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	(0@0) corner: (976@665)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
OupsDebuggerSystem>>suspendDebuggedProcess:
8 January 2025 2:35:13.537253 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	345712
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	345712
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
8 January 2025 2:35:13.567629 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(1012322304)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345726 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	345712
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	345712
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
OupsDebuggerSystem>>suspendDebuggedProcess:
8 January 2025 2:35:13.759042 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	345931
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	345931
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
8 January 2025 2:35:13.779682 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 60d66b41-80dd-0d00-bdda-516c033ccd3c Sep  2 2024
v10.3.1 - Commit: 6cdb1e5d - Date: 2024-09-02 09:56:37 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.733.sha.84ac714ffba8714a230aa922fa00820535e52b32 (64 Bit)]

OupsDebuggerSystem>>suspendDebuggedProcess:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebuggerSystem>>openDebuggerOnRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		debuggerOpeningStrategy: 	an OupsDebuggerSelector
	Receiver's instance variables: 
an OupsDebuggerSystem

MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
		anOupsDebuggerSystem: 	an OupsDebuggerSystem
	Receiver's instance variables: 
		activeTranscript: 	nil


[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ self signalDebuggerError: aDebugRequest ]
	Receiver's instance variables: 
		outerContext: 	OupsDebuggerSystem>>handleDebugRequest:
		compiledBlock: 	a CompiledBlock: [ self defaultUIManager handleDebugRequest:[..]
		numArgs: 	0
		receiver: 	an OupsDebuggerSystem


OupsDebuggerSystem>>handleDebugRequest:
	Receiver: an OupsDebuggerSystem
	Arguments and temporary variables: 
		aDebugRequest: 	an OupsDebugRequest
	Receiver's instance variables: 
an OupsDebuggerSystem

OupsDebugRequest>>submit
	Receiver: an OupsDebugRequest
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		exception: 	I am an Oups NULL debugging exception
		context: 	Process>>debugWithTitle:
		label: 	'Debug'
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		compiledMethod: 	nil
		preDebugActions: 	an OrderedCollection()
		debugSession: 	a DebugSession


[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
		requestClass: 	OupsDebugRequest
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
			[..]
	Arguments and temporary variables: 
		anArg: 	OupsDebugRequest
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess[..]
		compiledBlock: 	a CompiledBlock: [ :requestClass |
			(requestClass newForCo[..]
		numArgs: 	1
		receiver: 	a MorphicUIManager


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#OupsDebugRequest
		aBlock: 	[ :requestClass |
			(requestClass newForContext: aContext)
				pro[..]
		assoc: 	#OupsDebugRequest->OupsDebugRequest
	Receiver's instance variables: 
		tally: 	10014
		array: 	an Array(#ReSourceCodeLineTest->ReSourceCodeLineTest #MicMathBlock->[..]
		cachedClassNames: 	nil
		cachedNonClassNames: 	nil
		cachedBehaviors: 	nil
		reservedVariables: 	a Dictionary(#self->self #super->super #thisContext->thi[..]


MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aProcess: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		title: 	'Debug'
		aContext: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		activeTranscript: 	nil


Process>>debugWithTitle:
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
		title: 	'Debug'
		context: 	Process>>debugWithTitle:
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Process>>debug
	Receiver: a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	OupsDebuggerSystem>>suspendDebuggedProcess:
		priority: 	40
		myList: 	nil
		name: 	'Morphic UI Process'
		env: 	a WeakArray(nil a Job nil nil nil nil nil nil nil nil nil nil an IceMe[..]
		effectiveProcess: 	nil
		terminating: 	false
		level: 	nil


Job>>debug
	Receiver: a Job
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
        [..]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading baseline of BaselineOfRoassal3Exporters'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	nil
		process: 	a Process in OupsDebuggerSystem>>suspendDebuggedProcess:
		owner: 	a MorphicUIManager


JobProgressMorph>>debug
	Receiver: a JobProgressMorph(436512512)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(22.0@28.0) corner: (347.0@61.0)
		owner: 	a SystemProgressMorph(661916416)
		submorphs: 	an Array(a StringMorph(616809984)'Loading baseline of BaselineOf[..]
		fullBounds: 	(22@28) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (822100992) [other:  (announcer -> an Announcer)]
		bar: 	a JobProgressBarMorph(365584896)
		endValue: 	nil
		hasResult: 	false
		job: 	a Job
		labelMorph: 	a StringMorph(616809984)'Loading baseline of BaselineOfRoassal3[..]
		lastRefresh: 	0
		lock: 	a Semaphore()
		result: 	nil
		startValue: 	nil


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
		arity: 	0
	Receiver's instance variables: 
		event: 	#mouseUp
		selector: 	#debug
		recipient: 	a JobProgressMorph(436512512)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) ==[..]
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(328@59) mouseUp 339546 nil]
		eventType: 	#mouseUp
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseUp:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(328@59) mouseUp 339546 nil]
		sourceMorph: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseUp->a Set(a MorphEventSubscription) )


JobProgressBarMorph(Morph)>>handleMouseUp:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


MouseButtonEvent>>sentTo:
	Receiver: [(328@59) mouseUp 339546 nil]
	Arguments and temporary variables: 
		anObject: 	a JobProgressBarMorph(365584896)
	Receiver's instance variables: 
		timeStamp: 	339546
		source: 	a HandMorph(511132416)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(328@59)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


JobProgressBarMorph(Morph)>>handleEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


JobProgressBarMorph(Morph)>>handleFocusEvent:
	Receiver: a JobProgressBarMorph(365584896)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(22.0@45.0) corner: (347.0@61.0)
		owner: 	a JobProgressMorph(436512512)
		submorphs: 	an Array(a ProgressBarMorph(54940416) an ImageMorph(1039613696))
		fullBounds: 	(22@45) corner: (347@61)
		color: 	Color transparent
		extension: 	a MorphExtension (862310912) [eventHandler = a MorphicEventHandler] 
		progressBar: 	a ProgressBarMorph(54940416)


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex |
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		compiledBlock: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent:[..]
		numArgs: 	0
		receiver: 	a HandMorph(511132416)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(331683328) [world]
		transformedEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		focusHolder: 	a JobProgressBarMorph(365584896)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(511132416)
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
		evt: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		bounds: 	(337@51) corner: (353@67)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	#()
		fullBounds: 	(337@51) corner: (353@67)
		color: 	Color blue
		extension: 	a MorphExtension (62200064)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarMorph(115025920)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(337@51) mouseUp 345933 nil]
		targetOffset: 	(315.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(328@59) mouseUp 339546 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(331683328) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNo[..]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	345931
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(331683328) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(511132416))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	334554
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	345931
		activeHand: 	a HandMorph(511132416)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
	[..]
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	nil
		deferredUIMessages: 	WaitfreeQueue with 0 items


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(331683328) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (976@665)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(717648128) a TaskbarMorph(514262784) a S[..]
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.940371456500[..]
		extension: 	a MorphExtension (384680704) [other:  (dragEnabled -> true) (dro[..]
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alph[..]
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


SystemProgressMorph>>refresh
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


SystemProgressMorph>>close:
	Receiver: a SystemProgressMorph(661916416)
	Arguments and temporary variables: 
		aSystemProgressItemMorph: 	a JobProgressMorph(419341312)
	Receiver's instance variables: 
		bounds: 	(10.0@20.0) corner: (359.0@107.0)
		owner: 	a WorldMorph(331683328) [world]
		submorphs: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563[..]
		fullBounds: 	(10@20) corner: (359@107)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.82306940371456[..]
		extension: 	a MorphExtension (364148480) [other:  (morphicLayerNumber -> 12)[..]
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.673509[..]
		lock: 	a Semaphore()
		lastRefresh: 	339656


[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
	Receiver: SystemProgressMorph
	Arguments and temporary variables: 
		aJobEnd: 	a JobEnd
		bars: 	an Array(a JobProgressMorph(436512512) a JobProgressMorph(370563840) [..]
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#addItemShowing:->SystemProgressMorph>>#addI[..]
		format: 	65546
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	#()
		name: 	#SystemProgressMorph
		classPool: 	a Dictionary(#UniqueInstance->a SystemProgressMorph(661916416) )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-ProgressBar'
		announcer: 	nil
		horizontalPosition: 	0
		verticalPosition: 	0



--- The full stack ---
OupsDebuggerSystem>>suspendDebuggedProcess:
OupsDebuggerSystem>>openDebuggerOnRequest:
MorphicUIManager>>handleDebugRequest:fromDebuggerSystem:
[ self defaultUIManager handleDebugRequest: aDebugRequest fromDebuggerSystem: self] in OupsDebuggerSystem>>handleDebugRequest:
FullBlockClosure(BlockClosure)>>on:do:
OupsDebuggerSystem>>handleDebugRequest:
OupsDebugRequest>>submit
[ :requestClass |
			(requestClass newForContext: aContext)
				process: aProcess;
				label: title;
				submit.
			^ self ] in MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
MorphicUIManager(UIManager)>>requestDebuggerOpeningForProcess:named:inContext:
Process>>debugWithTitle:
Process>>debug
Job>>debug
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
SystemProgressMorph>>refresh
SystemProgressMorph>>close:
[ :bars | self uniqueInstance close: bars last ] in SystemProgressMorph class>>endJob:
 - - - - - - - - - - - - - - -
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:
Array(Collection)>>ifNotEmpty:
SystemProgressMorph class>>endJob:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[action cull: anAnnouncement cull: announcer] in AnnouncementSubscription>>deliver:
FullBlockClosure(BlockClosure)>>on:do:
FullBlockClosure(BlockClosure)>>on:fork:
AnnouncementSubscription>>deliver:
[ subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
FullBlockClosure(BlockClosure)>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
Job>>announce:
Job>>cleanupAfterRunning
[ self cleanupAfterRunning ] in Job>>run
Context>>resume:through:
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			MetacelloNotification signal:
					'Loading -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description.
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
RSWorldMenu class>>loadExporters
[ self loadExporters ] in RSWorldMenu class>>menu06PluginsOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
CustomQuestionDialogWindow(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>customQuestionIn:text:yesText:noText:cancelText:default:title:
MorphicUIManager>>confirm:label:trueChoice:falseChoice:cancelChoice:default:
MorphicUIManager>>confirm:trueChoice:falseChoice:cancelChoice:default:
WorldState class>>quitSession
[ WorldState quitSession ] in [ self currentWorld defer: [ WorldState quitSession ] ] in OSWorldRenderer>>initialize
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
-- and more not shown ---------------------------------------------------------------------------------


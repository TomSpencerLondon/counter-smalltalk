----QUIT----2024-11-27T16:17:43.827608+01:00 Pharo11-SNAPSHOT-64bit-84ac714ffb.image priorSource: 0!----QUIT----2024-11-27T16:17:43.828352+01:00 Pharo11-SNAPSHOT-64bit-84ac714ffb.image priorSource: 0!----QUIT----2024-11-27T16:18:02.336542+01:00 Pharo11-SNAPSHOT-64bit-84ac714ffb.image priorSource: 102!----QUIT----2024-11-27T16:18:02.337298+01:00 Pharo11-SNAPSHOT-64bit-84ac714ffb.image priorSource: 204!Object subclass: #Counter	instanceVariableNames: 'count' 	classVariableNames: ''	package: 'MyCounter'!025-01-08T13:38:31.115494+00:00 Counter.image priorSource: 308!!Counter commentStamp: 'TomSpencer 1/8/2025 13:41' prior: 0!'Counter' is a simple concrete class which supports incrementing and decrementing.Its API is- `decrement` and `increment`- `count`Its creation message is `startAt:`!!Counter methodsFor: 'as yet unclassified' stamp: 'TomSpencer 1/8/2025 13:49'!count	^count	! !Counter removeSelector: #count!!Counter methodsFor: 'as yet unclassified' stamp: 'TomSpencer 1/8/2025 13:50'!count	^count! !TestCase subclass: #CounterTest	instanceVariableNames: '' 	classVariableNames: ''	package: 'MyCounter'!!CounterTest methodsFor: 'as yet unclassified' stamp: 'TomSpencer 1/8/2025 13:54'!testCountIsSetAndRead	| c |	c := Counter new.	c count: 7	self assert: c count equals: 7! !!Counter methodsFor: 'as yet unclassified' stamp: 'TomSpencer 1/8/2025 13:58'!count:	amount! !Object subclass: #MyClass	instanceVariableNames: 'count' 	classVariableNames: ''	package: 'MyCounter'!Smalltalk globals removeClassNamed: #AnObsoleteMyClass!Counter removeSelector: #count:!!Counter methodsFor: 'as yet unclassified' stamp: 'TomSpencer 1/8/2025 14:06'!count: aNumber    count := aNumber.! !!CounterTest methodsFor: 'tests' stamp: 'TomSpencer 1/8/2025 14:10' prior: 33555666!testCountIsSetAndRead    | c |    c := Counter new.    c count: 7.    self assert: c count equals: 7.! !!CounterTest methodsFor: 'tests' stamp: 'TomSpencer 1/8/2025 14:12' prior: 33556261!testCountIsSetAndRead    | c |    c := Counter new.    c count: 7.    self assert: c count equals: 7.! !!CounterTest methodsFor: 'tests' stamp: 'TomSpencer 1/8/2025 14:14' prior: 33556456!testCountIsSetAndRead | c |    c := Counter new.    c count: 7.    self assert: c count equals: 7.! !CounterTest removeSelector: #testCountIsSetAndRead!!CounterTest methodsFor: 'as yet unclassified' stamp: 'TomSpencer 1/8/2025 14:15'!testCountIsSetAndRead | c |    c := Counter new.    c count: 7.    self assert: c count equals: 7.! !!CounterTest methodsFor: 'tests' stamp: 'TomSpencer 1/8/2025 14:15' prior: 33556893!testCountIsSetAndRead | c |    c := Counter new.    c count: 7.    self assert: c count equals: 7.! !CounterTest removeSelector: #testCountIsSetAndRead!!CounterTest methodsFor: 'as yet unclassified' stamp: 'TomSpencer 1/8/2025 14:15'!testCountIsSetAndRead | c |    c := Counter new.    c count: 7.    self assert: c count equals: 7.! !----QUIT----2025-01-08T14:18:25.59564+00:00 Counter.image priorSource: 308!----QUIT----2025-01-08T14:18:25.597808+00:00 Counter.image priorSource: 2996!----QUIT/NOSAVE----2025-01-08T14:28:19.631438+00:00 Counter.image priorSource: 3073!---SNAPSHOT----2025-01-08T14:21:21.203412+00:00 Counter.image priorSource: 3152!----QUIT/NOSAVE----2025-01-08T14:28:16.643867+00:00 Counter.image priorSource: 3235!----QUIT/NOSAVE----2025-01-08T14:28:16.646098+00:00 Counter.image priorSource: 3235!----QUIT/NOSAVE----2025-01-08T14:28:19.634337+00:00 Counter.image priorSource: 3073!!BaselineOfRoassal3Exporters commentStamp: '' prior: 0!I load roassal3 and Roassal3-Exporters!!BaselineOfRoassal3Exporters methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ | hasCanvas |			"our dependencies"			"https://github.com/ObjectProfile/Roassal3Exporters"			hasCanvas := Smalltalk globals includesKey: #RSCanvas.			hasCanvas ifFalse: [				spec				baseline: 'Roassal3'				with: [ spec repository: 'github://ObjectProfile/Roassal3/src' ].			].			spec				baseline: 'OSSubprocess'				with: [ spec repository: 'github://pharo-contributions/OSSubprocess/repository' ].			spec				baseline: 'Units'				with: [ spec repository: 'github://zweidenker/Units' ].			"The packages to use, but not load"			spec				package: #'Roassal3-Exporters' with: [					spec requires: (hasCanvas						ifTrue: [ #('Units') ]						ifFalse: [ #('Units' 'Roassal3') ])					 ];				package: #'Roassal3-Exporters-Examples';				package: #'Roassal3-Exporters-Tests';				package: #'Roassal3-Exporters-Video' with: [spec requires: #('OSSubprocess') ];				package: #'Roassal3-Exporters-AFrame';				package: 'Roassal3-Exporters-AFrame-Examples';				package: #'Roassal3-Exporters-AFrame-Tests'.			spec				group: 'Core' with: #(					'Roassal3-Exporters'					'Roassal3-Exporters-Examples'					'Roassal3-Exporters-Tests');				group: 'Video' with: #(					'Core'					'Roassal3-Exporters-Video');				group: 'AFrame' with: #(					'Core'					'Roassal3-Exporters-AFrame'					'Roassal3-Exporters-AFrame-Tests'					'Roassal3-Exporters-AFrame-Examples'				);				group: 'default' with: #('Core') ]! !"BaselineOfRoassal3Exporters"!!BaselineOfUnits methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #'common' do: [				spec 			package: 'Units-Core';			package: 'Units-Tests' with: [ spec requires: 'Units-Core' ].					spec 			group: 'default' with: #('core' 'test');			group: 'core'     with: #('Units-Core');			group: 'test'      with: #('Units-Tests')].					 ! !"BaselineOfUnits"!!MessageDelegate commentStamp: '' prior: 0!An object that passes messages on to a private delegate!!SIPrefix commentStamp: '' prior: 0!SIPrefix represents a power of 10 attached to a unit.Examples: milli, micro, kilo, etc.!!Unit commentStamp: '' prior: 0!Class Unit is the superclass for all other unit classes.Instances represent units which are attached to numbers; for example'meters' (a BaseUnit), 'meters per second' (a CompoundUnit),'joule seconds per liter' (a ComplexUnit), 'degrees Kelvin' (a TemperatureBaseUnit),'degrees Celsius' (a TemperatureUnit), 'kilohertz' (a PrefixedUnit),and 'moles of hydrogen' (a ModifiedUnit).A number of methods on the class side of Unit provide for easy access to built-in units.The basic unit 'kilogram' is special given that it is basic and has a 'kilo' prefix, seealso http://www.bipm.org/en/si/si_brochure/chapter3/3-2.html!!CompoundUnit commentStamp: '' prior: 0!Instances of CompoundUnits represent units which are combinationsof base units (only).Examples of things that are CompoundUnits:	meters per second	cubic meters per degree Kelvin	grams per mole of calcium	Examples of things that are not CompoundUnits:		miles per hour	cubic meters per degree Farenheit	kilograms per mole!!ComplexUnit commentStamp: '' prior: 0!This represents a product of one or more different units.!!ModifiedUnit commentStamp: '' prior: 0!A base unit with an arbitrary modification that makes it incompatiblewith anything that does not have the same modification.  Works well with domain-specific'modifications', e.g.,	1.6 molescan now become:	1.6 moles of sulfuric acid("sulfuric acid" might be a String, or a ChemicalCompound, or whatever.)!!NamedUnit commentStamp: '' prior: 0!This is a kind of unit with a specific (singular and plural) name, and an abbreviation. e.g., meter, meters, m.!!BaseUnit commentStamp: '' prior: 0!This represents one of the SI base units.By default the following "official" units are defined:	gram	meter	second	candela (light intensity)	mole (pseudo-dimensionless quantity)	Two 'extra' base units are included to demonstrate how to extend the system:	base pairs (nucleotides on a DNA strand, for automatic analysis)	donuts (e.g., 1 homer = 8 donuts/minute)!!TemperatureBaseUnit commentStamp: '' prior: 0!Temperature units are different because they requirea general linear transformation for basic arithmetic operations.!!DerivedUnit commentStamp: '' prior: 0!This is a definition of a unit in terms of a product of powers ofother units, plus a scalar value associated with the unit.Example: 1 inch = 2.54 cmNote that the "left side" is always magnitude 1, which corresponds to 1 unit of the DerivedUnit. !!TemperatureUnit commentStamp: '' prior: 0!A temperature needs an additional "additive factor" to handle,e.g., Celsius to Fahrenheit.!!PrefixedUnit commentStamp: '' prior: 0!This is a unit with an SI prefix attached.See class SIPrefix for details.!!UnitValue commentStamp: '' prior: 0!UnitValue is a number with a unit attached.See the methods here for more information.!!MessageDelegate class methodsFor: 'instance creation'!on: anObject	"Answer a new instance of the receiver with the given delegate."	^self new privateDelegate: anObject! !!MessageDelegate methodsFor: 'system primitives'!doesNotUnderstand: aMessage	"Pass on to the delegate."		^self privateDelegate value: aMessage! !!MessageDelegate methodsFor: 'accessing'!privateDelegate	"Answer the value of privateDelegate"	^ privateDelegate! !!MessageDelegate methodsFor: 'accessing'!privateDelegate: anObject	"Set the value of privateDelegate"	privateDelegate := anObject! !!SIPrefix class methodsFor: 'initialization'!abbreviation: abbreviation name: prefixName scalingFactor: scalingFactor	| prefix |	prefix := self new		abbreviation: abbreviation		name: prefixName		scalingFactor: scalingFactor.	SIPrefixesByAbbreviation at: abbreviation put: prefix.	SIPrefixesByName at: prefixName put: prefix.	^prefix! !!SIPrefix class methodsFor: 'initialization'!initializeClass	"SIPrefix initializeClass."	"Do not rename this to #initialize."	SIPrefixesByName := Dictionary new.	SIPrefixesByAbbreviation := Dictionary new.	self abbreviation: 'y' name: 'yocto' scalingFactor: (10 raisedTo: -24).	self abbreviation: 'z' name: 'zepto' scalingFactor: (10 raisedTo: -21).	self abbreviation: 'a' name: 'atto' scalingFactor: (10 raisedTo: -18).	self abbreviation: 'f' name: 'femto' scalingFactor: (10 raisedTo: -15).	self abbreviation: 'p' name: 'pico' scalingFactor: (10 raisedTo: -12).	self abbreviation: 'n' name: 'nano' scalingFactor: (10 raisedTo: -9).	self abbreviation: 'u' name: 'micro' scalingFactor: (10 raisedTo: -6).	self abbreviation: 'm' name: 'milli' scalingFactor: (10 raisedTo: -3).	self abbreviation: 'c' name: 'centi' scalingFactor: (10 raisedTo: -2).	self abbreviation: 'd' name: 'deci' scalingFactor: (10 raisedTo: -1).	self abbreviation: 'da' name: 'deka' scalingFactor: (10 raisedTo: 1).	self abbreviation: 'h' name: 'hecto' scalingFactor: (10 raisedTo: 2).	self abbreviation: 'k' name: 'kilo' scalingFactor: (10 raisedTo: 3).	self abbreviation: 'M' name: 'mega' scalingFactor: (10 raisedTo: 6).	self abbreviation: 'G' name: 'giga' scalingFactor: (10 raisedTo: 9).	self abbreviation: 'T' name: 'tera' scalingFactor: (10 raisedTo: 12).	self abbreviation: 'P' name: 'peta' scalingFactor: (10 raisedTo: 15).	self abbreviation: 'E' name: 'exa' scalingFactor: (10 raisedTo: 18).	self abbreviation: 'Z' name: 'zetta' scalingFactor: (10 raisedTo: 21).	self abbreviation: 'Y' name: 'yotta' scalingFactor: (10 raisedTo: 24)! !!SIPrefix class methodsFor: 'accessing'!named: prefixName	^SIPrefixesByName at: prefixName! !!SIPrefix class methodsFor: 'enumerating'!prefixAbbreviationsDo: block	"Evaluate 'block' once with each prefix abbreviation, in no particular order."	SIPrefixesByAbbreviation keysDo: block! !!SIPrefix class methodsFor: 'enumerating'!prefixStringsDo: block	"Evaluate 'block' once with each prefix string, in no particular order."	SIPrefixesByName keysDo: block! !!SIPrefix class methodsFor: 'accessing'!withAbbreviation: abbreviation	^SIPrefixesByAbbreviation at: abbreviation! !!SIPrefix methodsFor: 'accessing'!abbreviation	^abbreviation! !!SIPrefix methodsFor: 'initialization'!abbreviation: myAbbreviation name: myName scalingFactor: myScalingFactor	abbreviation := myAbbreviation.	name := myName.	scalingFactor := myScalingFactor! !!SIPrefix methodsFor: 'accessing'!name	^name! !!SIPrefix methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream		nextPutAll: ' [';		nextPutAll: name;		nextPut: $]! !!SIPrefix methodsFor: 'accessing'!scalingFactor	^scalingFactor! !!SIPrefix methodsFor: 'printing'!storeOn: aStream	"Store the code to lookup the receiver instead of for a new instance."		aStream		nextPutAll: '(SIPrefix named: ''';		nextPutAll: name;		nextPutAll: ''')'! !!ComplexUnit class methodsFor: 'instance creation'!units: units exponents: exponents	"if we have just one exponent of size one, the unit itself is enough"	(exponents size = 1 and: [exponents first = 1]) ifTrue: [ ^units first ].	units		detect: [:each | each isBaseUnit not]		ifNone: [			"All the units are base units ... we can use a CompoundUnit instead to save space."			^CompoundUnit				units: units				exponents: exponents].	^self new		units: units		exponents: exponents! !!ComplexUnit methodsFor: 'conversion'!baseUnits	"Since base units are expensive to compute for ComplexUnits, they are cached here."	cachedBaseUnits isNil		ifTrue: [cachedBaseUnits := self calculateBaseUnits].	^cachedBaseUnits! !!ComplexUnit methodsFor: 'conversion'!calculateBaseUnits	| baseUnits unitDictionary newUnits newExponents scratch |	unitDictionary := IdentityDictionary new.	self unitsAndExponentsDo: [:unit :exponent |		baseUnits := unit baseUnits.		baseUnits unitsAndExponentsDo: [:subunit :subexponent |			(unitDictionary includesKey: subunit)				ifFalse: [					unitDictionary						at: subunit						put: subexponent * exponent]				ifTrue: [					unitDictionary						at: subunit						put: (unitDictionary at: subunit) + (subexponent * exponent)]]].	newUnits := OrderedCollection new.	newExponents := OrderedCollection new.	(unitDictionary keys asSortedCollection: self class sortBlock) do: [:unit |		scratch := unitDictionary at: unit.		scratch isZero ifFalse: [			newUnits add: unit.			newExponents add: scratch]].			^CompoundUnit		units: newUnits		exponents: newExponents! !!ComplexUnit methodsFor: 'consistency'!consistentWith: unit	^unit consistentWithComplexUnit: self! !!ComplexUnit methodsFor: 'consistency'!consistentWithBaseUnit: baseUnit	"This might be true, since we may be containing non-base units that reduce	 to the base unit."	"For example, 'meters * seconds * Hertz' is consistent with 'meters'."	^self baseUnits consistentWith: baseUnit! !!ComplexUnit methodsFor: 'consistency'!consistentWithComplexUnit: complexUnit	^self baseUnits consistentWith: complexUnit baseUnits! !!ComplexUnit methodsFor: 'consistency'!consistentWithCompoundUnit: compoundUnit	^self baseUnits consistentWith: compoundUnit! !!ComplexUnit methodsFor: 'consistency'!consistentWithModifiedUnit: modifiedUnit	"This might be true, since we may be containing non-base units that reduce to the	 modified unit."	"For example, 'moles of hydrogen * seconds * Hertz' is consistent with 'moles of	 hydrogen'."	^self baseUnits consistentWith: modifiedUnit! !!ComplexUnit methodsFor: 'conversion'!conversionFactor	^conversionFactor! !!ComplexUnit methodsFor: 'testing'!isComplexUnit	^ true! !!ComplexUnit methodsFor: 'conversion'!prefixedBy: prefixName	^self error: 'You cannot attach prefixes to complex units.'! !!ComplexUnit methodsFor: 'initialization'!units: myUnits exponents: myExponents	super units: myUnits exponents: myExponents.	conversionFactor := 1.	units with: exponents do: [:unit :exponent |		conversionFactor := conversionFactor * 			(unit conversionFactor raisedTo: exponent)]! !!CompoundUnit class methodsFor: 'instance creation'!null	"A special CompoundUnit used to coerce numbers into the Unit domain."	^self		units: #()		exponents: #()! !!CompoundUnit class methodsFor: 'sorting'!sortBlock	^[:left :right | left abbreviation < right abbreviation]! !!CompoundUnit class methodsFor: 'instance creation'!units: units exponents: exponents	^self new		units: units		exponents: exponents! !!CompoundUnit methodsFor: 'comparing'!= anotherUnit	"This is not the same as #consistentWith:, which checks for isomorphism.  This method	 just checks to see if the receiver and argument have the same units and exponents."	anotherUnit class == self class ifFalse: [^false].	^units = anotherUnit snarfUnits		and: [exponents = anotherUnit snarfExponents]! !!CompoundUnit methodsFor: 'conversion'!baseUnits	"The receiver already consists entirely of base units."	^self! !!CompoundUnit methodsFor: 'consistency'!consistentWith: unit	^unit consistentWithCompoundUnit: self! !!CompoundUnit methodsFor: 'consistency'!consistentWithBaseUnit: baseUnit	"Always false, because a CompoundUnit must always have a nontrivial set of units."	^false! !!CompoundUnit methodsFor: 'consistency'!consistentWithComplexUnit: complexUnit	^self consistentWith: complexUnit baseUnits! !!CompoundUnit methodsFor: 'consistency'!consistentWithCompoundUnit: compoundUnit	"We can check the unit and exponent arrays for equality directly, since the units are assumed to be sorted alphabetically."	^units = compoundUnit snarfUnits		and: [exponents = compoundUnit snarfExponents]! !!CompoundUnit methodsFor: 'consistency'!consistentWithModifiedUnit: modifiedUnit	"Same as #consistentWithBaseUnit:."	^false! !!CompoundUnit methodsFor: 'conversion'!conversionFactor	^1! !!CompoundUnit methodsFor: 'comparing'!hash	^units hash bitXor: exponents hash! !!CompoundUnit methodsFor: 'predicates'!includesNegativeExponents	^exponents anySatisfy: [:each | each < 0]! !!CompoundUnit methodsFor: 'predicates'!includesPositiveExponents	^exponents anySatisfy: [:each | each > 0]! !!CompoundUnit methodsFor: 'conversion'!inverse	^self class		units: units		exponents: (exponents collect: [:each | each negated])! !!CompoundUnit methodsFor: 'predicates'!isNull	^units isEmpty! !!CompoundUnit methodsFor: 'predicates'!negativeExponentsCount	| count |	count := 0.	exponents do: [:each | each < 0 ifTrue: [count := count + 1]].	^count! !!CompoundUnit methodsFor: 'predicates'!positiveExponentsCount	| count |	count := 0.	exponents do: [:each | each > 0 ifTrue: [count := count + 1]].	^count! !!CompoundUnit methodsFor: 'conversion'!prefixedBy: prefixName	^self error: 'You cannot attach prefixes to compound units.'! !!CompoundUnit methodsFor: 'printing'!printAbbreviationOn: stream	| first any count |	first := true.	any := false.	self unitsAndExponentsDo: [:unit :exponent |		exponent > 0 ifTrue: [			any := true.			first ifFalse: [stream nextPut: $*].			first := false.			unit printAbbreviationOn: stream.			exponent ~= 1				ifTrue: [stream nextPut: $^; print: exponent]]].	count := self negativeExponentsCount.	count > 0 ifTrue: [		any ifFalse: [stream nextPut: $1].		stream nextPut: $/.		count > 1 ifTrue: [stream nextPut: $(].		first := true.		self unitsAndExponentsDo: [:unit :exponent |			exponent ~= 1 ifTrue: [				first ifFalse: [stream nextPut: $*].				first := false.				unit printAbbreviationOn: stream.				exponent < -1 ifTrue: [stream nextPut: $^; print: exponent negated]]].		count > 1 ifTrue: [stream nextPut: $)]]! !!CompoundUnit methodsFor: 'printing'!printFullNameOn: stream pluralized: pluralized	"Print the full name of this unit, pluralized if 'pluralized' is true."	| positive negative |	positive := self includesPositiveExponents.	negative := self includesNegativeExponents.	positive ifTrue: [		self 			printUnitsWhereExponent: [:each | each > 0]			on: stream			pluralized: pluralized].	(negative and: [positive]) ifTrue: [stream space].	negative ifTrue: [		stream nextPutAll: 'per '.		self			printUnitsWhereExponent: [:each | each < 0]			on: stream			pluralized: false]! !!CompoundUnit methodsFor: 'printing'!printUnitsWhereExponent: block on: stream pluralized: pluralized	| power first count index thisPlural |	first := true.	count := (exponents select: block) size.	index := 0.	units with: exponents do: [:unit :exponent |		(block value: exponent) ifTrue: [			first ifTrue: [first := false] ifFalse: [stream space].			index := index + 1.			thisPlural := pluralized and: [index = count].			power := exponent abs.			(power isInteger and: [power <= 3]) ifTrue: [				power = 2 ifTrue: [stream nextPutAll: 'square '].				power = 3 ifTrue: [stream nextPutAll: 'cubic ']].			unit printFullNameOn: stream pluralized: thisPlural.			(power > 3 or: [power isInteger not]) ifTrue: [				stream					nextPut: $^;					print: power]]]! !!CompoundUnit methodsFor: 'unit arithmetic'!raisedTo: exponent	^self class		units: units		exponents: (exponents collect: [:each | each * exponent])! !!CompoundUnit methodsFor: 'unit arithmetic'!reciprocal	"Just make a new unit of the same class, with all the exponents negated."	^self class		units: units		exponents: (exponents collect: [:each | each negated])! !!CompoundUnit methodsFor: 'private'!snarfExponents	^exponents! !!CompoundUnit methodsFor: 'private'!snarfUnits	^units! !!CompoundUnit methodsFor: 'initialization'!units: myUnits exponents: myExponents	units := myUnits.	exponents := myExponents! !!CompoundUnit methodsFor: 'enumerating'!unitsAndExponentsDo: block	units with: exponents do: block! !!ModifiedUnit class methodsFor: 'instance creation'!baseUnit: baseUnit modification: modification	^self new		baseUnit: baseUnit		modification: modification! !!ModifiedUnit methodsFor: 'comparing'!= anotherUnit	self class = anotherUnit class ifFalse: [^false].	modification = anotherUnit modification ifFalse: [^false].	^baseUnit = anotherUnit baseUnit! !!ModifiedUnit methodsFor: 'accessing'!baseUnit	^baseUnit! !!ModifiedUnit methodsFor: 'initialization'!baseUnit: myBaseUnit modification: myModification	baseUnit := myBaseUnit.	modification := myModification! !!ModifiedUnit methodsFor: 'conversion'!baseUnits	^self! !!ModifiedUnit methodsFor: 'consistency'!consistentWith: anotherUnit	^anotherUnit consistentWithModifiedUnit: self! !!ModifiedUnit methodsFor: 'consistency'!consistentWithBaseUnit: anotherBaseUnit	^false! !!ModifiedUnit methodsFor: 'consistency'!consistentWithComplexUnit: complexUnit	^self consistentWith: complexUnit baseUnits! !!ModifiedUnit methodsFor: 'consistency'!consistentWithCompoundUnit: compoundUnit	^false! !!ModifiedUnit methodsFor: 'consistency'!consistentWithModifiedUnit: modifiedUnit	self class == modifiedUnit class ifFalse: [^false].	^baseUnit = modifiedUnit baseUnit		and: [modification = modifiedUnit modification]! !!ModifiedUnit methodsFor: 'conversion'!conversionFactor	^baseUnit conversionFactor! !!ModifiedUnit methodsFor: 'comparing'!hash	^modification hash bitXor: baseUnit hash! !!ModifiedUnit methodsFor: 'predicates'!isBaseUnit	"ModifiedUnits are effectively new base units..."	^true! !!ModifiedUnit methodsFor: 'accessing'!modification	^modification! !!ModifiedUnit methodsFor: 'printing'!printAbbreviationOn: stream	baseUnit printAbbreviationOn: stream.	stream nextPut: $(.	modification isString		ifTrue: [stream nextPutAll: modification]		ifFalse: [stream print: modification].	stream nextPut: $)! !!ModifiedUnit methodsFor: 'printing'!printFullNameOn: stream pluralized: pluralized	baseUnit printFullNameOn: stream pluralized: pluralized.	stream nextPutAll: ' (of '.	"Can't avoid the #isString, since strings print differently than other objects,	 and it is valid to have non-strings as the modification."	modification isString		ifTrue: [stream nextPutAll: modification]		ifFalse: [stream print: modification].	stream nextPut: $)! !!BaseUnit class methodsFor: 'initialization'!addUnit: unitName plural: pluralName abbreviation: abbreviation	| unit |	unit := self new		abbreviation: abbreviation		name: unitName		pluralName: pluralName.	SIUnitsByName at: unitName put: unit.	SIUnitsByPluralName at: pluralName put: unit.	SIUnitsByAbbreviation at: abbreviation put: unit.	^unit! !!BaseUnit class methodsFor: 'base units'!ampere	^self withSingularName: 'ampere'! !!BaseUnit class methodsFor: 'base units'!amperes	^self ampere! !!BaseUnit class methodsFor: 'example'!basePair	^self withPluralName: 'base pair'! !!BaseUnit class methodsFor: 'example'!basePairs	^ self withPluralName: 'base pairs'! !!BaseUnit class methodsFor: 'base units'!candela	^self withSingularName: 'candela'! !!BaseUnit class methodsFor: 'example'!donut	^ self withSingularName: 'donut'! !!BaseUnit class methodsFor: 'example'!donuts	^ self donut! !!BaseUnit class methodsFor: 'initialization'!initializeClass	"BaseUnit initializeClass."	"Do not rename this to #initialize."	PrintAbbreviated := false.  "may as well do it here ..."	SIUnitsByName := Dictionary new.	SIUnitsByAbbreviation := Dictionary new.	SIUnitsByPluralName := Dictionary new.	self		addUnit: 'kilogram' plural: 'kilograms' abbreviation: 'kg';		addUnit: 'metre' plural: 'metres' abbreviation: 'm';		addUnit: 'second' plural: 'seconds' abbreviation: 's';		addUnit: 'candela' plural: 'candela' abbreviation: 'cd';		addUnit: 'mole' plural: 'moles' abbreviation: 'mol';		addUnit: 'ampere' plural: 'amperes' abbreviation: 'A';		"Kelvin is defined in subclass"		addUnit: 'radian' plural: 'radians' abbreviation: 'rad';		addUnit: 'base pair' plural: 'base pairs' abbreviation: 'BP';  "for DNA"		addUnit: 'donut' plural: 'donuts' abbreviation: 'donut';		addUnit: 'volt' plural: 'volts' abbreviation: 'V'! !!BaseUnit class methodsFor: 'base units'!kelvin	^self withSingularName: 'kelvin'! !!BaseUnit class methodsFor: 'base units'!kilogram	^self withSingularName: 'kilogram'! !!BaseUnit class methodsFor: 'base units'!kilograms	^ self kilogram! !!BaseUnit class methodsFor: 'base units'!meter	^self metre! !!BaseUnit class methodsFor: 'base units'!meters	^self metre! !!BaseUnit class methodsFor: 'base units'!metre	^self withSingularName: 'metre'! !!BaseUnit class methodsFor: 'base units'!metres	^ self metre! !!BaseUnit class methodsFor: 'base units'!mole	^self withSingularName: 'mole'! !!BaseUnit class methodsFor: 'base units'!moles	^self mole! !!BaseUnit class methodsFor: 'base units'!second	^self withSingularName: 'second'! !!BaseUnit class methodsFor: 'base units'!seconds	^ self second! !!BaseUnit class methodsFor: 'base units'!volt	^self withSingularName: 'volt'! !!BaseUnit class methodsFor: 'base units'!volts	^self volt! !!BaseUnit class methodsFor: 'accessing'!withAbbreviation: abbreviation ifAbsent: exceptionBlock	^SIUnitsByAbbreviation		at: abbreviation		ifAbsent: exceptionBlock! !!BaseUnit class methodsFor: 'accessing'!withPluralName: unitName ifAbsent: exceptionBlock	^SIUnitsByPluralName		at: unitName		ifAbsent: exceptionBlock! !!BaseUnit class methodsFor: 'accessing'!withSingularName: unitName ifAbsent: exceptionBlock	^SIUnitsByName		at: unitName		ifAbsent: exceptionBlock! !!BaseUnit methodsFor: 'conversion'!baseUnits	"This is already a base unit."	^self! !!BaseUnit methodsFor: 'consistency'!consistentWith: unit	^unit consistentWithBaseUnit: self! !!BaseUnit methodsFor: 'consistency'!consistentWithBaseUnit: unit	^self == unit! !!BaseUnit methodsFor: 'consistency'!consistentWithComplexUnit: complexUnit	^self consistentWith: complexUnit baseUnits! !!BaseUnit methodsFor: 'conversion'!conversionFactor	^1.  "by definition"! !!BaseUnit methodsFor: 'predicates'!isBaseUnit	^true! !!BaseUnit methodsFor: 'printing'!storeOn: aStream	"Store the code to lookup the receiver instead of for a new instance."		aStream		nextPutAll: '(BaseUnit withPluralName: ''';		nextPutAll: self pluralName;		nextPutAll: ''')'! !!TemperatureBaseUnit methodsFor: 'predicates'!isZeroAsValue: value	^false! !!TemperatureBaseUnit methodsFor: 'conversion'!uncheckedConvertFrom: anotherUnitValue	| newValue |	newValue :=		(anotherUnitValue value - anotherUnitValue unitPart additiveFactor) *		(anotherUnitValue unit conversionFactorTo: self).	^UnitValue unit: self value: newValue! !!DerivedUnit class methodsFor: 'instance creation'!abbreviation: abbreviation name: unitName pluralName: pluralName value: unitValue	| unit |	unit := super		abbreviation: abbreviation		name: unitName		pluralName: pluralName.	unit value: unitValue.	^unit! !!DerivedUnit methodsFor: 'conversion'!baseUnits	^unitValue unit baseUnits! !!DerivedUnit methodsFor: 'consistency'!consistentWith: unit	"Short-circuit the double dispatching here."	^unitValue unitPart consistentWith: unit! !!DerivedUnit methodsFor: 'consistency'!consistentWithBaseUnit: baseUnit	^baseUnit consistentWith: self unit! !!DerivedUnit methodsFor: 'consistency'!consistentWithComplexUnit: complexUnit	^complexUnit consistentWith: self unit! !!DerivedUnit methodsFor: 'consistency'!consistentWithCompoundUnit: compoundUnit	^compoundUnit consistentWith: self unit! !!DerivedUnit methodsFor: 'consistency'!consistentWithModifiedUnit: modifiedUnit	^modifiedUnit consistentWith: self unit! !!DerivedUnit methodsFor: 'conversion'!conversionFactor	^unitValue value * unitValue unit conversionFactor! !!DerivedUnit methodsFor: 'accessing'!unit	^unitValue unit! !!DerivedUnit methodsFor: 'initialization'!value: myUnitValue	unitValue := myUnitValue! !!TemperatureUnit class methodsFor: 'instance creation'!abbreviation: abbreviationname: unitNamepluralName: pluralNamevalue: unitValueadditiveFactor: additiveFactor	| unit |	unit := super		abbreviation: abbreviation		name: unitName		pluralName: pluralName		value: unitValue.	unit additiveFactor: additiveFactor.	^unit! !!TemperatureUnit methodsFor: 'accessing'!additiveFactor	^additiveFactor! !!TemperatureUnit methodsFor: 'initialization'!additiveFactor: myAdditiveFactor	additiveFactor := myAdditiveFactor! !!TemperatureUnit methodsFor: 'predicates'!isZeroAsValue: value	! !!TemperatureUnit methodsFor: 'conversion'!uncheckedConvertFrom: anotherUnitValue	| kelvin newValue |	^anotherUnitValue unit isBaseUnit		ifTrue: [			newValue :=				(anotherUnitValue value / 					(self conversionFactorTo: anotherUnitValue unit)) + additiveFactor.			UnitValue				unit: self				value: newValue]		ifFalse: [			kelvin := anotherUnitValue uncheckedConvertTo: Unit kelvin.			kelvin convertTo: self]! !!NamedUnit class methodsFor: 'instance creation'!abbreviation: abbreviation name: unitName pluralName: pluralName	"Create and index a new NamedUnit."	| unit |	unit := self new		abbreviation: abbreviation		name: unitName		pluralName: pluralName.	UnitsByAbbreviation at: abbreviation put: unit.	UnitsByName at: unitName put: unit.	UnitsByPluralName at: pluralName put: unit.	^unit! !!NamedUnit class methodsFor: 'instance creation'!abbreviation: abbreviation name: unitName pluralName: pluralName value: unitValue	^DerivedUnit		abbreviation: abbreviation		name: unitName		pluralName: pluralName		value: unitValue! !!NamedUnit class methodsFor: 'instance creation'!abbreviation: abbreviationname: unitNamepluralName: pluralNamevalue: unitValueadditiveFactor: additiveFactor	^TemperatureUnit		abbreviation: abbreviation		name: unitName		pluralName: pluralName		value: unitValue		additiveFactor: additiveFactor! !!NamedUnit class methodsFor: 'initialization'!initializeAreaUnits	self		abbreviation: 'acre'		name: 'acre'		pluralName: 'acres'		value: (4046.87260987 units: Unit metre squared).	self		abbreviation: 'a'		name: 'are'		pluralName: 'ares'		value: (100 units: Unit metre squared)! !!NamedUnit class methodsFor: 'initialization'!initializeClass	"NamedUnit initializeClass."	"Do not rename this to #initialize."	UnitsByAbbreviation := Dictionary new.	UnitsByName := Dictionary new.	UnitsByPluralName := Dictionary new.	self initializeUnits! !!NamedUnit class methodsFor: 'initialization'!initializeForceUnits	self		abbreviation: 'N'		name: 'newton'		pluralName: 'newtons'		value: (1 units: (Unit kilogram * Unit metre) / Unit second squared)! !!NamedUnit class methodsFor: 'initialization'!initializeLengthUnits	self		abbreviation: 'in'		name: 'inch'		pluralName: 'inches'		value: (2.54 units: Unit centimetre).	self		abbreviation: 'ft'		name: 'foot'		pluralName: 'feet'		value: (12 units: Unit inch).	self		abbreviation: 'yd'		name: 'yard'		pluralName: 'yards'		value: (3 units: Unit foot).	self		abbreviation: 'mi'		name: 'mile'		pluralName: 'miles'		value: (5280 units: Unit foot).	self		abbreviation: 'nm'		name: 'nauticalmile'		pluralName: 'nauticalmiles'		value: (1852 units: Unit metre).	self		abbreviation: 'pt'		name: 'point'		pluralName: 'points'		value: (1/72 units: Unit inch).	self		abbreviation: 'pc'		name: 'pica'		pluralName: 'picas'		value: (12 units: Unit point).	self		abbreviation: 'px'		name: 'pixel'		pluralName: 'pixels'		value: (0.2635872 units: Unit millimetre).	self		abbreviation: 'L'		name: 'litre'		pluralName: 'litres'		value: (1/1000 units: (Unit metre raisedTo: 3)).	self		abbreviation: 'ua'		name: 'astronomical unit'		pluralName: 'astronomical units'		value: ((1.49598 raisedTo: 11) units: Unit metre).	self		abbreviation: 'angstrom'		name: 'angstrom'		pluralName:'angstroms'		value: (1e-10 units: Unit metre)! !!NamedUnit class methodsFor: 'initialization'!initializeMassUnits	"Initialize the mass units."		self		abbreviation: 't'		name: 'tonne'		pluralName: 'tonnes'		value: (1000 units: Unit kilogram).	self		abbreviation: 'lb'		name: 'pound'		pluralName: 'pounds'		value: (0.45359237 units: Unit kilogram).	self		abbreviation: 'oz'		name: 'ounce'		pluralName: 'ounces'		value: (1/16 units: Unit pound).	self		abbreviation: 'st'		name: 'stone'		pluralName: 'stone'		value: (14 units: Unit pound).	self		abbreviation: 'g'		name: 'gram'		pluralName: 'grams'		value: ((1/1000) units: BaseUnit kilogram).! !!NamedUnit class methodsFor: 'initialization'!initializeOtherUnits	self		abbreviation: 'C'		name: 'coulomb'		pluralName: 'coulombs'		value: (1 units: ((Unit second) * (Unit ampere))).	self		abbreviation: 'F'		name: 'farad'		pluralName: 'farads'		value: (1 units: ((Unit coulomb) / (Unit ampere))).	self		abbreviation: 'W'		name: 'watt'		pluralName: 'watts'		value: (1 units: ((Unit ampere) * (Unit volt))).			DerivedUnit		abbreviation: 'deg'		name: 'arcdegree'		pluralName: 'arcdegrees'		value: (1 degreesToRadians units: Unit radian).! !!NamedUnit class methodsFor: 'initialization'!initializeTemperatureUnits	TemperatureBaseUnit		abbreviation: 'K'		name: 'kelvin'		pluralName: 'kelvins'.	self		abbreviation: '°F'		name: 'degree Fahrenheit'		pluralName: 'degrees Fahrenheit'		value: (5/9 units: Unit kelvin)		additiveFactor: -459.67.	self		abbreviation: '°C'		name: 'degree Celsius'		pluralName: 'degrees Celsius'		value: (1 units: Unit kelvin)		additiveFactor: -273.15! !!NamedUnit class methodsFor: 'initialization'!initializeTimeUnits	self		abbreviation: 'min'		name: 'minute'		pluralName: 'minutes'		value: (60 units: Unit second).	self		abbreviation: 'h'		name: 'hour'		pluralName: 'hours'		value: (60 units: Unit minute).	self		abbreviation: 'd'		name: 'day'		pluralName: 'days'		value: (24 units: Unit hour).	self		abbreviation: 'yr'		name: 'year'		pluralName: 'years'		value: (365.25 units: Unit day). "use Julian year"	self		abbreviation: 'Hz'		name: 'hertz'		pluralName: 'hertz'		value: 1 / (1 units: Unit second)! !!NamedUnit class methodsFor: 'initialization'!initializeUnits	self		initializeAreaUnits;		initializeLengthUnits;		initializeMassUnits;		initializeForceUnits;		initializeTemperatureUnits;		initializeTimeUnits;		initializeOtherUnits! !!NamedUnit class methodsFor: 'accessing'!withAbbreviation: abbreviation ifAbsent: exceptionBlock	^UnitsByAbbreviation		at: abbreviation		ifAbsent: exceptionBlock! !!NamedUnit class methodsFor: 'accessing'!withPluralName: pluralName ifAbsent: exceptionBlock	^UnitsByPluralName		at: pluralName		ifAbsent: exceptionBlock! !!NamedUnit class methodsFor: 'accessing'!withSingularName: unitName ifAbsent: exceptionBlock	^UnitsByName		at: unitName		ifAbsent: exceptionBlock! !!NamedUnit methodsFor: 'accessing'!abbreviation	^abbreviation! !!NamedUnit methodsFor: 'initialization'!abbreviation: myAbbreviation name: myName pluralName: myPluralName	abbreviation := myAbbreviation.	name := myName.	pluralName := myPluralName! !!NamedUnit methodsFor: 'accessing'!name	^name! !!NamedUnit methodsFor: 'accessing'!pluralName	^pluralName! !!NamedUnit methodsFor: 'printing'!printAbbreviationOn: stream	stream nextPutAll: abbreviation! !!NamedUnit methodsFor: 'printing'!printFullNameOn: stream pluralized: pluralized	pluralized		ifTrue: [stream nextPutAll: pluralName]		ifFalse: [stream nextPutAll: name]! !!NamedUnit methodsFor: 'printing'!storeOn: aStream	"Store the code to lookup the receiver instead of for a new instance."		aStream		nextPutAll: '(NamedUnit withPluralName: ''';		nextPutAll: self pluralName;		nextPutAll: ''')'! !!PrefixedUnit class methodsFor: 'instance creation'!prefix: prefix unit: unit	^self new prefix: prefix unit: unit! !!PrefixedUnit class methodsFor: 'instance creation'!prefixName: prefixName unit: unit	| prefix |	prefix := SIPrefix named: prefixName.	^self prefix: prefix unit: unit! !!PrefixedUnit methodsFor: 'comparing'!= anotherUnit	self class == anotherUnit class ifFalse: [^false].	^prefix = anotherUnit prefix and: [unit = anotherUnit unit]! !!PrefixedUnit methodsFor: 'conversion'!baseUnits	^unit baseUnits! !!PrefixedUnit methodsFor: 'consistency'!consistentWith: anotherUnit	"Short-circuit the double dispatching; just compare the actual unit."	^anotherUnit consistentWith: unit! !!PrefixedUnit methodsFor: 'consistency'!consistentWithAnything: anotherUnit	^unit consistentWith: anotherUnit! !!PrefixedUnit methodsFor: 'conversion'!conversionFactor	^prefix scalingFactor * unit conversionFactor! !!PrefixedUnit methodsFor: 'comparing'!hash	^prefix hash bitXor: unit hash! !!PrefixedUnit methodsFor: 'accessing'!prefix	^prefix! !!PrefixedUnit methodsFor: 'initialization'!prefix: myPrefix unit: myUnit	prefix := myPrefix.	unit := myUnit! !!PrefixedUnit methodsFor: 'conversion'!prefixedBy: prefixName	^self error: 'This unit already has a prefix.'! !!PrefixedUnit methodsFor: 'printing'!printAbbreviationOn: stream	stream nextPutAll: prefix abbreviation.	unit printAbbreviationOn: stream! !!PrefixedUnit methodsFor: 'printing'!printFullNameOn: stream pluralized: pluralized	stream nextPutAll: prefix name.	unit printFullNameOn: stream pluralized: pluralized! !!PrefixedUnit methodsFor: 'accessing'!unit	^unit! !!Unit class methodsFor: 'SI base units'!A	^ self ampere! !!Unit class methodsFor: 'miscellaneous units'!C	^ self coulomb! !!Unit class methodsFor: 'miscellaneous units'!F	^ self farad! !!Unit class methodsFor: 'time units'!GHz	^self gigahertz! !!Unit class methodsFor: 'time units'!Hz	^self hertz! !!Unit class methodsFor: 'SI base units'!K	^self kelvin ! !!Unit class methodsFor: 'time units'!MHz	^self megahertz! !!Unit class methodsFor: 'mass units'!Mt	^self megatonne! !!Unit class methodsFor: 'area units'!a	^ self are! !!Unit class methodsFor: 'miscellaneous units'!ampere	^ BaseUnit ampere! !!Unit class methodsFor: 'miscellaneous units'!amperes	^ self ampere! !!Unit class methodsFor: 'mass units'!angstrom	^NamedUnit named: 'angstrom'! !!Unit class methodsFor: 'mass units'!angstroms	^self angstrom! !!Unit class methodsFor: 'miscellaneous units'!arcdegree	^ NamedUnit named: 'arcdegree'! !!Unit class methodsFor: 'miscellaneous units'!arcdegrees	^ self arcdegree! !!Unit class methodsFor: 'area units'!are	^ NamedUnit named: 'are'! !!Unit class methodsFor: 'area units'!ares	^ self are! !!Unit class methodsFor: 'miscellaneous units'!candela	^ BaseUnit candela! !!Unit class methodsFor: 'SI base units'!cd	^self candela! !!Unit class methodsFor: 'length units'!centimeter	^ self centimetre! !!Unit class methodsFor: 'length units'!centimeters	^ self centimetre! !!Unit class methodsFor: 'length units'!centimetre	^ self metre prefixedBy: 'centi'! !!Unit class methodsFor: 'length units'!centimetres	^ self centimetre! !!Unit class methodsFor: 'length units'!cm	^self centimetre! !!Unit class methodsFor: 'generalized lookup'!commonUnits	"Answer the common units as a collection."	^{self pixel. self point. self pica. self millimetre.		self centimetre. self metre. self kilometre.		self inch. self foot. self yard. self mile}! !!Unit class methodsFor: 'miscellaneous units'!coulomb	^ NamedUnit named: 'coulomb'! !!Unit class methodsFor: 'miscellaneous units'!coulombs	^self coulomb! !!Unit class methodsFor: 'time units'!day	^ NamedUnit named: 'day'! !!Unit class methodsFor: 'time units'!days	^ self day! !!Unit class methodsFor: 'miscellaneous units'!deg	^ self arcdegree! !!Unit class methodsFor: 'temperature units'!degreeCelsius	^ NamedUnit named: 'degree Celsius'! !!Unit class methodsFor: 'temperature units'!degreeFahrenheit	^ NamedUnit named: 'degree Fahrenheit'! !!Unit class methodsFor: 'temperature units'!degreeKelvin	^ self kelvin! !!Unit class methodsFor: 'temperature units'!degreesCelsius	^ self degreeCelsius! !!Unit class methodsFor: 'temperature units'!degreesFahrenheit	^ self degreeFahrenheit! !!Unit class methodsFor: 'temperature units'!degreesKelvin	^ self kelvin! !!Unit class methodsFor: 'miscellaneous units'!degs	^ self arcdegree! !!Unit class methodsFor: 'time units'!dy	^self days! !!Unit class methodsFor: 'miscellaneous units'!farad	^NamedUnit named: 'farad'! !!Unit class methodsFor: 'miscellaneous units'!farads	^ self farad! !!Unit class methodsFor: 'length units'!feet	^ self foot! !!Unit class methodsFor: 'length units'!foot	^NamedUnit named: 'foot'! !!Unit class methodsFor: 'length units'!ft	^self foot! !!Unit class methodsFor: 'mass units'!g	^ self gram! !!Unit class methodsFor: 'time units'!gigahertz	^self hertz prefixedBy: 'giga'! !!Unit class methodsFor: 'power units'!gigavolt	^ self volt prefixedBy: 'giga'! !!Unit class methodsFor: 'mass units'!gram	^NamedUnit named: 'gram'! !!Unit class methodsFor: 'mass units'!grams	^ self gram! !!Unit class methodsFor: 'miscellaneous units'!gramsPerMole	^ Unit gram / Unit mole! !!Unit class methodsFor: 'time units'!h	^ self hour! !!Unit class methodsFor: 'area units'!ha	^ self hectare! !!Unit class methodsFor: 'area units'!hectare	^ self are prefixedBy: 'hecto'! !!Unit class methodsFor: 'area units'!hectares	^ self hectare! !!Unit class methodsFor: 'time units'!hertz	^NamedUnit named: 'hertz'! !!Unit class methodsFor: 'time units'!hour	^ NamedUnit named: 'hour'! !!Unit class methodsFor: 'time units'!hours	^ self hour! !!Unit class methodsFor: 'length units'!in	^self inch! !!Unit class methodsFor: 'length units'!inch	^ NamedUnit named: 'inch'! !!Unit class methodsFor: 'length units'!inches	^ self inch! !!Unit class methodsFor: 'class initialization'!initialize	"Unit initialize."	"This is the master 'initialize' method.  It calls the #initializeClass methods of the	 classes in this package *in the appropriate order*.  The reason I don't just have the	 fileout code call #initialize for each class that needs initialization is that this	 package depends on classes being initialized in a certain order, and the 'topological'	 fileout order generated by some Smalltalks does not match this order."	SIPrefix initializeClass.	BaseUnit initializeClass.	NamedUnit initializeClass! !!Unit class methodsFor: 'time units'!kHz	^self kilohertz! !!Unit class methodsFor: 'temperature units'!kelvin	^ NamedUnit named: 'kelvin'! !!Unit class methodsFor: 'temperature units'!kelvins	^self kelvin ! !!Unit class methodsFor: 'SI base units'!kg	^self kilogram! !!Unit class methodsFor: 'mass units'!kilogram	^ BaseUnit kilogram! !!Unit class methodsFor: 'mass units'!kilograms	^ self kilogram! !!Unit class methodsFor: 'time units'!kilohertz	^self hertz prefixedBy: 'kilo'! !!Unit class methodsFor: 'length units'!kilometer	^ self kilometre! !!Unit class methodsFor: 'length units'!kilometers	^ self kilometre! !!Unit class methodsFor: 'length units'!kilometre	^ self metre prefixedBy: 'kilo'! !!Unit class methodsFor: 'length units'!kilometres	^ self kilometre! !!Unit class methodsFor: 'power units'!kilovolt	^ self volt prefixedBy: 'kilo'! !!Unit class methodsFor: 'power units'!kilowatt	^ self watt prefixedBy: 'kilo'! !!Unit class methodsFor: 'length units'!km	^self kilometre! !!Unit class methodsFor: 'mass units'!lb	^self pound! !!Unit class methodsFor: 'miscellaneous units'!liter	^ self litre! !!Unit class methodsFor: 'miscellaneous units'!liters	^ self litre! !!Unit class methodsFor: 'miscellaneous units'!litre	^ NamedUnit named: 'litre'! !!Unit class methodsFor: 'miscellaneous units'!litres	^ self litre! !!Unit class methodsFor: 'SI base units'!m	^self metre! !!Unit class methodsFor: 'time units'!megahertz	^self hertz prefixedBy: 'mega'! !!Unit class methodsFor: 'mass units'!megatonnes	^self tonne prefixedBy: 'mega'! !!Unit class methodsFor: 'power units'!megavolt	^ self volt prefixedBy: 'mega'! !!Unit class methodsFor: 'length units'!meter	^ self metre! !!Unit class methodsFor: 'length units'!meters	^ self metre! !!Unit class methodsFor: 'length units'!metre	^ BaseUnit metre! !!Unit class methodsFor: 'length units'!metres	^ self metre! !!Unit class methodsFor: 'mass units'!mg	^self milligram! !!Unit class methodsFor: 'length units'!mi	^self mile! !!Unit class methodsFor: 'mass units'!microgram	^self gram prefixedBy: 'micro'! !!Unit class methodsFor: 'mass units'!micrograms	^self microgram! !!Unit class methodsFor: 'length units'!mile	^NamedUnit named: 'mile'! !!Unit class methodsFor: 'length units'!miles	^ self mile! !!Unit class methodsFor: 'power units'!milliamp	^ self ampere prefixedBy: 'milli'! !!Unit class methodsFor: 'mass units'!milligram	^self gram prefixedBy: 'milli'! !!Unit class methodsFor: 'mass units'!milligrams	^self milligram! !!Unit class methodsFor: 'length units'!millimeter	^ self millimetre! !!Unit class methodsFor: 'length units'!millimeters	^ self millimetre! !!Unit class methodsFor: 'length units'!millimetre	^ self metre prefixedBy: 'milli'! !!Unit class methodsFor: 'time units'!milliseconds	^self second prefixedBy: 'milli'! !!Unit class methodsFor: 'power units'!millivolt	^ self volt prefixedBy: 'milli'! !!Unit class methodsFor: 'time units'!min	^self minutes! !!Unit class methodsFor: 'time units'!minute	^ NamedUnit named: 'minute'! !!Unit class methodsFor: 'time units'!minutes	^ self minute! !!Unit class methodsFor: 'length units'!mm	^self millimetre! !!Unit class methodsFor: 'SI base units'!mol	^ self moles! !!Unit class methodsFor: 'mass units'!mole	^ BaseUnit mole! !!Unit class methodsFor: 'mass units'!moles	^ self mole! !!Unit class methodsFor: 'time units'!ms	^self milliseconds! !!Unit class methodsFor: 'generalized lookup'!named: unitName	^self		withPluralName: unitName		ifAbsent: [self withSingularName: unitName]! !!Unit class methodsFor: 'generalized lookup'!named: unitName ifAbsent: exceptionBlock	^self		withPluralName: unitName		ifAbsent: [self withSingularName: unitName ifAbsent: exceptionBlock]! !!Unit class methodsFor: 'power units'!nanovolt	^ self volt prefixedBy: 'nano'! !!Unit class methodsFor: 'miscellaneous units'!newton	^NamedUnit named: 'newton'! !!Unit class methodsFor: 'miscellaneous units'!newtons	^NamedUnit named: 'newtons'! !!Unit class methodsFor: 'mass units'!ounce	^NamedUnit named: 'ounce'! !!Unit class methodsFor: 'mass units'!ounces	^ self ounce! !!Unit class methodsFor: 'mass units'!oz	^self ounce! !!Unit class methodsFor: 'length units'!pc	^ self pica! !!Unit class methodsFor: 'length units'!pica	^ NamedUnit named: 'pica'! !!Unit class methodsFor: 'length units'!picas	^ self pica! !!Unit class methodsFor: 'power units'!picovolt	^ self volt prefixedBy: 'pico'! !!Unit class methodsFor: 'length units'!pixel	^ NamedUnit named: 'pixel'! !!Unit class methodsFor: 'length units'!pixels	^ self pixel! !!Unit class methodsFor: 'length units'!point	^ NamedUnit named: 'point'! !!Unit class methodsFor: 'length units'!points	^ self point! !!Unit class methodsFor: 'mass units'!pound	^NamedUnit named: 'pound'! !!Unit class methodsFor: 'mass units'!pounds	^NamedUnit named: 'pounds'! !!Unit class methodsFor: 'parameters'!printAbbreviated	^PrintAbbreviated! !!Unit class methodsFor: 'parameters'!printAbbreviated: boolean	"Should we print units in abbreviated format?"	PrintAbbreviated := boolean! !!Unit class methodsFor: 'length units'!pt	^ self point! !!Unit class methodsFor: 'length units'!px	^ self pixel! !!Unit class methodsFor: 'miscellaneous units'!rad	^ self radian! !!Unit class methodsFor: 'miscellaneous units'!radian	^ BaseUnit named: 'radian'! !!Unit class methodsFor: 'miscellaneous units'!radians	^ self rad! !!Unit class methodsFor: 'SI base units'!s	^ self second! !!Unit class methodsFor: 'time units'!second	^ BaseUnit second! !!Unit class methodsFor: 'time units'!seconds	^ self second! !!Unit class methodsFor: 'mass units'!st	^self stone! !!Unit class methodsFor: 'mass units'!stone	^NamedUnit named: 'stone'! !!Unit class methodsFor: 'mass units'!t	^self tonne! !!Unit class methodsFor: 'mass units'!tonne	^NamedUnit named: 'tonne'! !!Unit class methodsFor: 'mass units'!tonnes	^ self tonne! !!Unit class methodsFor: 'length units'!ua	^NamedUnit named: 'astronomical unit'! !!Unit class methodsFor: 'power units'!volt	^ BaseUnit volt! !!Unit class methodsFor: 'power units'!volts	^ BaseUnit volts! !!Unit class methodsFor: 'power units'!watt	^ NamedUnit named: 'watt'! !!Unit class methodsFor: 'power units'!watts	^ NamedUnit named: 'watts'! !!Unit class methodsFor: 'generalized lookup'!withAbbreviation: abbreviation	^self		withAbbreviation: abbreviation		ifAbsent: [self error: 'There is no unit with the abbreviation ', abbreviation printString, '.']! !!Unit class methodsFor: 'generalized lookup'!withAbbreviation: unitName ifAbsent: exceptionBlock	| unit |	unit := NamedUnit withAbbreviation: unitName ifAbsent: [nil].	unit isNil ifFalse: [^unit].	unit := BaseUnit withAbbreviation: unitName ifAbsent: exceptionBlock.	^unit! !!Unit class methodsFor: 'generalized lookup'!withPluralName: unitName	^self		withPluralName: unitName		ifAbsent: [self error: 'There is no unit named ', unitName printString, '.']! !!Unit class methodsFor: 'generalized lookup'!withPluralName: unitName ifAbsent: exceptionBlock	| unit |	unit := NamedUnit withPluralName: unitName ifAbsent: [nil].	unit isNil ifFalse: [^unit].	unit := BaseUnit withPluralName: unitName ifAbsent: exceptionBlock.	^unit! !!Unit class methodsFor: 'generalized lookup'!withSingularName: unitName	^self		withSingularName: unitName		ifAbsent: [self error: 'There is no unit named ', unitName printString, '.']! !!Unit class methodsFor: 'generalized lookup'!withSingularName: unitName ifAbsent: exceptionBlock	| unit |	unit := NamedUnit withSingularName: unitName ifAbsent: [nil].	unit isNil ifFalse: [^unit].	unit := BaseUnit withSingularName: unitName ifAbsent: exceptionBlock.	^unit! !!Unit class methodsFor: 'length units'!yard	^ NamedUnit named: 'yard'! !!Unit class methodsFor: 'length units'!yards	^ self yard! !!Unit class methodsFor: 'length units'!yd	^ self yard! !!Unit class methodsFor: 'time units'!year	^ NamedUnit named: 'year'! !!Unit class methodsFor: 'time units'!years	^ self year! !!Unit class methodsFor: 'time units'!yr	^self year! !!Unit class methodsFor: 'mass units'!µg	^self microgram! !!Unit methodsFor: 'unit arithmetic'!* anotherUnit	^self multipliedBy: anotherUnit! !!Unit methodsFor: 'unit arithmetic'!/ anotherUnit	^self dividedBy: anotherUnit! !!Unit methodsFor: 'accessing'!abbreviation	"Answer an abbreviation for the receiver."	| stream |	stream := WriteStream on: String new.	self printAbbreviationOn: stream.	^stream contents! !!Unit methodsFor: 'conversion'!additiveFactor	"Only TemperatureUnits have additive factors."	^0! !!Unit methodsFor: 'conversion'!baseUnits	"Answer a Unit object that represents the receiver in reduced form (i.e., with all 'complex' units replaced by SI units)."	self subclassResponsibility! !!Unit methodsFor: 'consistency'!consistentWith: unit	"Is the receiver 'consistent' with the argument?  Two units must be consistent in order to be added or subtracted."	self subclassResponsibility! !!Unit methodsFor: 'consistency'!consistentWithAnything: anotherUnit	^false! !!Unit methodsFor: 'consistency'!consistentWithBaseUnit: baseUnit	^self consistentWithAnything: baseUnit! !!Unit methodsFor: 'consistency'!consistentWithComplexUnit: compositeUnit	^self consistentWithAnything: compositeUnit! !!Unit methodsFor: 'consistency'!consistentWithCompoundUnit: compositeUnit	^self consistentWithAnything: compositeUnit! !!Unit methodsFor: 'consistency'!consistentWithModifiedUnit: modifiedUnit	^self consistentWithAnything: modifiedUnit! !!Unit methodsFor: 'conversion'!conversionFactor	"Answer the factor by which the receiver is larger than the base units from which it is composed."	^self subclassResponsibility! !!Unit methodsFor: 'conversion'!conversionFactorTo: anotherUnit	"Assuming the receiver is consistent with 'anotherUnit', answer a number which represents the amount that a value with the receiver as a unit must be multiplied by to convert to 'anotherUnit' (got it?)"	^self conversionFactor / anotherUnit conversionFactor! !!Unit methodsFor: 'unit arithmetic'!dividedBy: anotherUnit	^self multipliedBy: anotherUnit reciprocal! !!Unit methodsFor: 'conversion'!factor: anotherUnit	"Factor with respect 'anotherUnit'; answer a new unit equivalent to the receiver."	| thisBase argumentBase result |	thisBase := self baseUnits.	argumentBase := anotherUnit baseUnits.	result := thisBase dividedBy: argumentBase.	^anotherUnit multipliedBy: result! !!Unit methodsFor: 'predicates'!isBaseUnit	"Answer true if the receiver represents a simple SI base unit with no modifications."	^false! !!Unit methodsFor: 'testing'!isComplexUnit	^ false! !!Unit methodsFor: 'predicates'!isNull	^false! !!Unit methodsFor: 'predicates'!isZeroAsValue: value	"If 'value' were the value of a UnitValue with this unit,would it equal zero?  Most units are absolute (e.g., length) so thisanswers true for zero values.  Some units are not; for examplethe Celsius and Fahrenheit temperature scales."	^value isZero! !!Unit methodsFor: 'conversion'!modify: modification	"Answer a ModifiedUnit with the receiver and the given modification."	self isBaseUnit ifFalse: [self error: 'You can only modify base units.'].	^ModifiedUnit baseUnit: self modification: modification! !!Unit methodsFor: 'unit arithmetic'!multipliedBy: anotherUnit	| unitDictionary units exponents scratch |	unitDictionary := Dictionary new.	self unitsAndExponentsDo: [:unit :exponent |		(unitDictionary includesKey: unit)			ifTrue: [unitDictionary at: unit put: (unitDictionary at: unit) + exponent]			ifFalse: [unitDictionary at: unit put: exponent]].	anotherUnit unitsAndExponentsDo: [:unit :exponent |		(unitDictionary includesKey: unit)			ifTrue: [unitDictionary at: unit put: (unitDictionary at: unit) + exponent]			ifFalse: [unitDictionary at: unit put: exponent]].	units := OrderedCollection new.	exponents := OrderedCollection new.	(unitDictionary keys asSortedCollection: CompoundUnit sortBlock) do: [:unit |		scratch := unitDictionary at: unit.		scratch isZero ifFalse: [			units add: unit.			exponents add: scratch]].	units size = 1 ifTrue: [		(exponents at: 1) = 1 ifTrue: [^units at: 1]].	^ComplexUnit units: units exponents: exponents! !!Unit methodsFor: 'unit arithmetic'!per: anotherUnit	^self dividedBy: anotherUnit! !!Unit methodsFor: 'accessing'!plural	"Answer the plural for the receiver."		| stream |	stream := WriteStream on: String new.	self printFullNameOn: stream pluralized: true.	^stream contents! !!Unit methodsFor: 'conversion'!prefixedBy: prefixName	^PrefixedUnit		prefixName: prefixName		unit: self! !!Unit methodsFor: 'printing'!printAbbreviationOn: stream	"Print the receiver abbreviated."	self subclassResponsibility! !!Unit methodsFor: 'printing'!printFullNameOn: stream pluralized: pluralized	"Print the full name of this unit, pluralized if 'pluralized' is true."	self subclassResponsibility! !!Unit methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPutAll: ' ['.	PrintAbbreviated		ifTrue: [self printAbbreviationOn: stream]		ifFalse: [self printFullNameOn: stream pluralized: true].	stream nextPut: $]! !!Unit methodsFor: 'unit arithmetic'!raisedTo: exponent	"Answer the receiver raised to the given exponent."	^ComplexUnit		units: (Array with: self)		exponents: (Array with: exponent)! !!Unit methodsFor: 'unit arithmetic'!reciprocal	"Answer the inverse of the receiver."	^ComplexUnit		units: (Array with: self)		exponents: (Array with: -1)! !!Unit methodsFor: 'unit arithmetic'!squared	^self multipliedBy: self! !!Unit methodsFor: 'conversion'!uncheckedConvertFrom: unitValue	"This is a double-dispatching message used by UnitValue."	| factor |	factor := unitValue unit conversionFactorTo: self.	^UnitValue		unit: self		value: unitValue value * factor! !!Unit methodsFor: 'private'!unitPart	"For compatibility with UnitValue."	^self! !!Unit methodsFor: 'enumerating'!unitsAndExponentsDo: block	"Evaluate the block once for each unit/exponent pair contained within the receiver.	 For scalar units, just evaluate the block once with 'self', exponent 1."	block value: self value: 1! !!Unit methodsFor: 'conversion'!value: number	"Coerce the receiver to be a UnitValue with the given value."	^UnitValue		unit: self		value: number! !!Unit methodsFor: 'conversion'!veryDeepCopyWith: deepCopier	"Return self.  Don't copy units  Do not record me."! !!String methodsFor: '*Units-Core'!asUnit	"Answer the receiver as a unit."		^UnitValue unitFor: self asSymbol! !!String methodsFor: '*Units-Core'!asUnitValue	"Answer the receiver as a unit value."		|n p i|	n := self asNumber.	i := self findString: (p := n printString).	i = 0 ifTrue: [^nil].	^n units: (self allButFirst: p size) withBlanksTrimmed asUnit	! !!Point methodsFor: '*Units-Core'!as	"Answer a delegate on the receiver #as: to handle the next message."		^MessageDelegate on: [:m | self as: m selector]! !!Point methodsFor: '*Units-Core'!as: anotherUnit	"Convert the receiver to have the same units as 'anotherUnit'.  Apply any appropriate	 scaling factors.  Gives an error if the receiver's x and y are not consistent with 'anotherUnit'."		^(self x as: anotherUnit) @ (self y as: anotherUnit)! !!Point methodsFor: '*Units-Core'!value	"Answer a new point with the x and y being the respective	values of the receiver's ordinates."		^self x value @ self y value! !!Number methodsFor: '*Units-Core'!A	^self units: #ampere! !!Number methodsFor: '*Units-Core'!C	^self units: #coulomb! !!Number methodsFor: '*Units-Core'!F	^self units: #farad! !!Number methodsFor: '*Units-Core'!GHz	^self units: #gigahertz! !!Number methodsFor: '*Units-Core'!GV	^ self units: #gigavolt! !!Number methodsFor: '*Units-Core'!Hz	^self units: #hertz! !!Number methodsFor: '*Units-Core'!K	^self units: #kelvin! !!Number methodsFor: '*Units-Core'!L	^ self units: #litre! !!Number methodsFor: '*Units-Core'!MHz	^self units: #megahertz! !!Number methodsFor: '*Units-Core'!MV	^ self units: #megavolt! !!Number methodsFor: '*Units-Core'!Mt	^self units: #megatonne! !!Number methodsFor: '*Units-Core'!V	^self units: #volt! !!Number methodsFor: '*Units-Core'!W	^self units: #watt! !!Number methodsFor: '*Units-Core'!a	^ self units: #are! !!Number methodsFor: '*Units-Core'!addToUnit: unitValue	^unitValue class		unit: unitValue unit		value: unitValue value + self! !!Number methodsFor: '*Units-Core'!angstrom	^self units: #angstrom! !!Number methodsFor: '*Units-Core'!angstroms	^self angstrom! !!Number methodsFor: '*Units-Core'!arcdegree	^self units: #arcdegree! !!Number methodsFor: '*Units-Core'!baseUnits	^ self! !!Number methodsFor: '*Units-Core'!candela	^self units: #candela! !!Number methodsFor: '*Units-Core'!cd	^self candela! !!Number methodsFor: '*Units-Core'!celsius	^self degreeCelsius! !!Number methodsFor: '*Units-Core'!centimeter	^self cm! !!Number methodsFor: '*Units-Core'!centimeters	^self cm! !!Number methodsFor: '*Units-Core'!cm	^self units: #centimeter! !!Number methodsFor: '*Units-Core'!degreeCelsius	^self units: #degreeCelsius! !!Number methodsFor: '*Units-Core'!degreeFahrenheit	^self units: #degreeFahrenheit! !!Number methodsFor: '*Units-Core'!degreeKelvin	^self kelvin! !!Number methodsFor: '*Units-Core'!divideIntoUnit: unitValue	^unitValue class		unit: unitValue unit		value: unitValue value / self! !!Number methodsFor: '*Units-Core'!equalFromUnit: unitValue	"Is 'unitValue' equal in magnitude to the receiver?"		^unitValue value = self! !!Number methodsFor: '*Units-Core'!fahrenheit	^self degreeFahrenheit! !!Number methodsFor: '*Units-Core'!feet	^self foot! !!Number methodsFor: '*Units-Core'!foot	^self units: #foot! !!Number methodsFor: '*Units-Core'!ft	^self foot! !!Number methodsFor: '*Units-Core'!g	^self units: #gram! !!Number methodsFor: '*Units-Core'!gigahertz	^self units: #gigahertz! !!Number methodsFor: '*Units-Core'!grams	^self g! !!Number methodsFor: '*Units-Core'!h	^ self units: #hour! !!Number methodsFor: '*Units-Core'!ha	^ self units: #hectare! !!Number methodsFor: '*Units-Core'!hertz	^self units: #hertz! !!Number methodsFor: '*Units-Core'!in	^self units: #inch! !!Number methodsFor: '*Units-Core'!inches	^self in! !!Number methodsFor: '*Units-Core'!kHz	^self units: #kilohertz! !!Number methodsFor: '*Units-Core'!kV	^self units: #kilovolt! !!Number methodsFor: '*Units-Core'!kW	^self units: #kilowatt! !!Number methodsFor: '*Units-Core'!kWh	^ (self units: #kilowatt) * (1 units: #hour)! !!Number methodsFor: '*Units-Core'!kelvin	^self units: #kelvin! !!Number methodsFor: '*Units-Core'!kg	^self units: #kilogram! !!Number methodsFor: '*Units-Core'!kilograms	^self kg! !!Number methodsFor: '*Units-Core'!kilohertz	^self units: #kilohertz! !!Number methodsFor: '*Units-Core'!kilometer	^self kilometre! !!Number methodsFor: '*Units-Core'!kilometers	^self kilometre! !!Number methodsFor: '*Units-Core'!kilometre	^self units: #kilometre! !!Number methodsFor: '*Units-Core'!km	^self kilometre! !!Number methodsFor: '*Units-Core'!lb	^self pound! !!Number methodsFor: '*Units-Core'!lessFromUnit: unitValue	"Does 'unitValue' have a smaller magnitude than us?"		^unitValue value < self! !!Number methodsFor: '*Units-Core'!liter	^self litre! !!Number methodsFor: '*Units-Core'!liters	^self litre! !!Number methodsFor: '*Units-Core'!litre	^self units: #litre! !!Number methodsFor: '*Units-Core'!m	^self metre! !!Number methodsFor: '*Units-Core'!mA	^self units: #milliamp! !!Number methodsFor: '*Units-Core'!mV	^self units: #millivolt! !!Number methodsFor: '*Units-Core'!megahertz	^self units: #megahertz! !!Number methodsFor: '*Units-Core'!megatonne	^self units: #megatonne! !!Number methodsFor: '*Units-Core'!meter	^self metre! !!Number methodsFor: '*Units-Core'!meters	^self metre! !!Number methodsFor: '*Units-Core'!metre	^self units: #metre! !!Number methodsFor: '*Units-Core'!mg	^self milligram! !!Number methodsFor: '*Units-Core'!mi	^ self units: #mile! !!Number methodsFor: '*Units-Core'!milligram	^ self units: #milligram! !!Number methodsFor: '*Units-Core'!millimeter	^self millimetre! !!Number methodsFor: '*Units-Core'!millimeters	^self millimetre! !!Number methodsFor: '*Units-Core'!millimetre	^ self units: #millimetre! !!Number methodsFor: '*Units-Core'!mm	^self millimetre! !!Number methodsFor: '*Units-Core'!multiplyByUnit: unitValue	^unitValue class		unit: unitValue unit		value: unitValue value * self! !!Number methodsFor: '*Units-Core'!nV	^self units: #nanovolt! !!Number methodsFor: '*Units-Core'!ounce	^ self units: #ounce! !!Number methodsFor: '*Units-Core'!oz	^self ounce! !!Number methodsFor: '*Units-Core'!pV	^self units: #picovolt! !!Number methodsFor: '*Units-Core'!pc	^self pica! !!Number methodsFor: '*Units-Core'!pica	^ self units: #pica! !!Number methodsFor: '*Units-Core'!pixel	^ self units: #pixel! !!Number methodsFor: '*Units-Core'!pixels	^ self pixel! !!Number methodsFor: '*Units-Core'!point	^ self units: #point! !!Number methodsFor: '*Units-Core'!pound	^self units: #pound! !!Number methodsFor: '*Units-Core'!pt	^self point! !!Number methodsFor: '*Units-Core'!px	^self pixel! !!Number methodsFor: '*Units-Core'!rad	^self radian! !!Number methodsFor: '*Units-Core'!radian	^self units: #rad! !!Number methodsFor: '*Units-Core'!radians	^self rad! !!Number methodsFor: '*Units-Core'!s	^ self units: #second! !!Number methodsFor: '*Units-Core'!st	^ self stone! !!Number methodsFor: '*Units-Core'!stone	^ self units: #stone! !!Number methodsFor: '*Units-Core'!stones	^ self st! !!Number methodsFor: '*Units-Core'!subtractFromUnit: unitValue	^unitValue class		unit: unitValue unit		value: unitValue value - self! !!Number methodsFor: '*Units-Core'!t	^ self tonne! !!Number methodsFor: '*Units-Core'!tonne	^ self units: #tonne! !!Number methodsFor: '*Units-Core'!tonnes	^ self t! !!Number methodsFor: '*Units-Core'!ua	^self units: #ua! !!Number methodsFor: '*Units-Core'!units: unitOrSymbol	^UnitValue 		unit: (UnitValue unitFor: unitOrSymbol)		value: self! !!Number methodsFor: '*Units-Core'!yard	^ self units: #yard! !!Number methodsFor: '*Units-Core'!yards	^ self yard! !!Number methodsFor: '*Units-Core'!yd	^self yard! !!Number methodsFor: '*Units-Core'!µg	^ self units: #microgram! !!UnitValue class methodsFor: 'instance creation'!one	^1! !!UnitValue class methodsFor: 'instance creation'!unit: unit value: value	^self basicNew unit: unit value: value! !!UnitValue class methodsFor: 'accessing'!unitFor: object	"Some methods in UnitValue (and Number>>#units:) can take either	 a Unit object, or a symbol representing a unit name, or a UnitValue object.  	 If it is a symbol, it is sent as a message to Unit class to retrieve the actual 	 unit object.  If it is a UnitValue, the unitPart is taken."		^object isSymbol		ifTrue: [Unit perform: object]		ifFalse: [object unitPart]! !!UnitValue class methodsFor: 'instance creation'!zero	^0! !!UnitValue methodsFor: 'arithmetic'!% number	self shouldNotImplement! !!UnitValue methodsFor: 'arithmetic'!* number	^number multiplyByUnit: self! !!UnitValue methodsFor: 'mathematical'!** exponent	^self raisedTo: exponent! !!UnitValue methodsFor: 'arithmetic'!+ number	^number addToUnit: self! !!UnitValue methodsFor: 'arithmetic'!- number	^number subtractFromUnit: self! !!UnitValue methodsFor: 'arithmetic'!/ number	^number divideIntoUnit: self! !!UnitValue methodsFor: 'comparing'!< number	^number lessFromUnit: self! !!UnitValue methodsFor: 'comparing'!= number	^number equalFromUnit: self! !!UnitValue methodsFor: 'arithmetic'!@ anObject	"Answer a new point with x being the receiver and y anObject."		^Point x: self y: anObject! !!UnitValue methodsFor: 'coercing'!adaptToInteger: rcvr andSend: selector	"handle coercion for mixed arithmetic	 uses the method already present for DD"	^(self coerce: rcvr) perform: selector with: self! !!UnitValue methodsFor: 'coercing'!adaptToNumber: rcvr andSend: selector	"handle coercion for mixed arithmetic	 uses the method already present for DD"	^(self coerce: rcvr) perform: selector with: self! !!UnitValue methodsFor: 'double dispatching'!addToUnit: unitValue	| sum |	^(self consistentWith: unitValue)		ifTrue: [			sum := self uncheckedConvertTo: unitValue.			sum setValue: unitValue value + sum value.			sum reduced]		ifFalse: [unitValue inconsistentUnits: self selector: #+]! !!UnitValue methodsFor: 'converting'!as	"Answer a delegate on the receiver #as: to handle the next message."		^MessageDelegate on: [:m | self as: m selector]! !!UnitValue methodsFor: 'converting'!as: anotherUnit	"Convert the receiver to have the same units as 'anotherUnit'.  Apply any appropriate	 scaling factors.  Gives an error if the receiver is not consistent with 'anotherUnit'."		^self convertTo: anotherUnit! !!UnitValue methodsFor: 'converting'!baseUnits	"Answer the receiver reduced to base units only."	^self convertTo: unit baseUnits! !!UnitValue methodsFor: 'rounding'!ceiling	^self class		unit: unit		value: value ceiling! !!UnitValue methodsFor: 'coercing'!coerce: number	^self class		unit: CompoundUnit null		value: number! !!UnitValue methodsFor: 'consistency'!consistentWith: anotherUnit	^unit consistentWith: anotherUnit unitPart! !!UnitValue methodsFor: 'converting'!convertTo: anotherUnit	"Convert the receiver to have the same units as 'anotherUnit'.  Apply any appropriate	 scaling factors.  Gives an error if the receiver is not consistent with 'anotherUnit'."	| u |	u := self class unitFor: anotherUnit.	^(u consistentWith: unit)		ifTrue: [u uncheckedConvertFrom: self]		ifFalse: [self inconsistentUnits: u selector: #convertTo:]! !!UnitValue methodsFor: 'printing'!cssString	"CSS is picky about units directly following the value."		|str|	str := (String new: 20) writeStream.	self value printOn: str.	self unit printAbbreviationOn: str.	^str contents! !!UnitValue methodsFor: 'double dispatching'!divideIntoUnit: unitValue	"Let the VM check for division by zero."	^(self class		unit: (unitValue unit dividedBy: unit)		value: unitValue value / value) 			reduced! !!UnitValue methodsFor: 'double dispatching'!equalFromUnit: unitValue	"Is 'unitValue' equal in magnitude to the receiver?"	| converted |	^(self consistentWith: unitValue)		ifTrue: ["self halt. *** why? ***"			converted := self uncheckedConvertTo: unitValue.			unitValue value = converted value]		ifFalse: [false]! !!UnitValue methodsFor: 'converting'!factor: unitValue	"Factor with respect to another Unit or UnitValue."	| newUnit |	newUnit := unit factor: (self class unitFor: unitValue).	^self convertTo: newUnit! !!UnitValue methodsFor: 'rounding'!floor	^self class		unit: unit		value: value floor! !!UnitValue methodsFor: 'coercing'!generality	^46! !!UnitValue methodsFor: 'comparing'!hash	"Answer a SmallInteger whose value is related to the receiver's identity.	May be overridden, and should be overridden in any classes that define = "	^self unit hash bitXor: self value hash! !!UnitValue methodsFor: 'consistency'!inconsistentUnits: argument selector: selector	self error:		'Inconsistent units for #', selector, ' between ',			self printString, ' and ', argument printString! !!UnitValue methodsFor: 'testing'!isZero	^unit isZeroAsValue: value! !!UnitValue methodsFor: 'double dispatching'!lessFromUnit: unitValue	"Does 'unitValue' have a smaller magnitude than us?"	| converted |	^(self consistentWith: unitValue)		ifTrue: [			converted := self uncheckedConvertTo: unitValue.			unitValue value < converted value]		ifFalse: [unitValue inconsistentUnits: self selector: #<]! !!UnitValue methodsFor: 'double dispatching'!multiplyByUnit: unitValue	^(self class		unit: (unit multipliedBy: unitValue unit)		value: unitValue value * value) reduced! !!UnitValue methodsFor: 'arithmetic'!negated	^self class		unit: unit		value: value negated! !!UnitValue methodsFor: 'testing'!negative	^value negative! !!UnitValue methodsFor: 'printing'!printAbbreviatedOn: stream	"Print the receiver in abbreviated form."		value printOn: stream.	stream space.	unit printAbbreviationOn: stream! !!UnitValue methodsFor: 'printing'!printOn: stream	value printOn: stream.	stream space.	Unit printAbbreviated		ifTrue: [unit printAbbreviationOn: stream]		ifFalse: [unit 					printFullNameOn: stream					pluralized: value ~= 1]! !!UnitValue methodsFor: 'printing'!printStringAbbreviated	"Answer the print string in abbreviated form."		|str|	str := (String new: 10) writeStream.	self printAbbreviatedOn: str.	^str contents! !!UnitValue methodsFor: 'mathematical'!raisedTo: exponent	^self class		unit: (unit raisedTo: exponent)		value: (value raisedTo: exponent)! !!UnitValue methodsFor: 'converting'!reduced	"If the receiver's units have 'vanished' (e.g., by dividing 2 seconds by 3 seconds),	 answer the remaining scalar part of the receiver.  Otherwise, answer the receiver	 unchanged."	^ unit isNull		ifTrue: [ value ]		ifFalse: [ 			(unit isComplexUnit and: [unit calculateBaseUnits isNull])				ifTrue: [ value * unit conversionFactor ]				ifFalse: [ self ] ]! !!UnitValue methodsFor: 'rounding'!roundTo: number	^self class		unit: unit		value: (value roundTo: number)! !!UnitValue methodsFor: 'rounding'!roundUpTo: number	^self class		unit: unit		value: (value roundUpTo: number)! !!UnitValue methodsFor: 'rounding'!rounded	^self class		unit: unit		value: value rounded! !!UnitValue methodsFor: 'private'!setUnit: aUnit	"Set the unit."		unit := aUnit! !!UnitValue methodsFor: 'private'!setValue: newValue	value := newValue! !!UnitValue methodsFor: 'testing'!sign	^value sign! !!UnitValue methodsFor: 'mathematical'!sqrt	^self class		unit: (unit raisedTo: 1/2)		value: value sqrt! !!UnitValue methodsFor: 'accessing'!storeOn: aStream	"Store the code to lookup the receiver instead of for a new instance."		|as|	as := String new writeStream.	self unit printAbbreviationOn: as.	(Unit respondsTo: as contents asSymbol)		ifTrue: [self value storeOn: aStream.				aStream					space;					nextPutAll: as contents]		ifFalse: [super storeOn: aStream]! !!UnitValue methodsFor: 'double dispatching'!subtractFromUnit: unitValue	"Subtract the receiver from the unitValue."		| sum |	^(self consistentWith: unitValue)		ifTrue: [			sum := self uncheckedConvertTo: unitValue.			sum setValue: unitValue value - sum value.			sum reduced]		ifFalse: [unitValue inconsistentUnits: self selector: #-]! !!UnitValue methodsFor: 'rounding'!truncateTo: number	^self class		unit: unit		value: (value truncateTo: number)! !!UnitValue methodsFor: 'rounding'!truncated	^self class		unit: unit		value: value truncated! !!UnitValue methodsFor: 'private'!uncheckedConvertTo: anotherUnit	^anotherUnit unitPart uncheckedConvertFrom: self! !!UnitValue methodsFor: 'accessing'!unit	^unit! !!UnitValue methodsFor: 'initialization'!unit: myUnit value: myValue	unit := myUnit.	value := myValue! !!UnitValue methodsFor: 'private'!unitPart	"Answer the unit part of the receiver."	^unit! !!UnitValue methodsFor: 'accessing'!value	"A special interpretation of #value to answer the scalar part of the unit."	^value! !"Units-Core"!----QUIT/NOSAVE----2025-01-08T14:35:18.193379+00:00 Counter.image priorSource: 3235!----QUIT/NOSAVE----2025-01-08T14:35:18.194752+00:00 Counter.image priorSource: 3235!----QUIT----2025-01-08T16:35:17.261627+00:00 Counter.image priorSource: 3235!----QUIT----2025-01-08T16:35:17.26472+00:00 Counter.image priorSource: 76245!